--- .backup/main.py	2025-11-08 13:47:57.000000000 +0530
+++ main.py	2025-11-08 13:48:29.000000000 +0530
@@ -3,75 +3,94 @@
 Orchestrates data cleaning, analysis, and report generation.
 """
 
-import csv
-import os
-from datetime import datetime
+from typing import List, Dict, Any
+from utils.data_utils import (
+    file_exists, read_csv_file, create_sample_csv,
+    clean_numeric_field, validate_required_fields
+)
+from utils.math_utils import round_to_decimal_places, calculate_statistics
+from utils.logging_utils import setup_logger, log_info, log_error, format_currency
 
-def main():
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Starting data processing pipeline...")
+
+def main() -> None:
+    """Main function to orchestrate the data processing pipeline."""
+    # Set up logger
+    logger = setup_logger('main')
+    
+    log_info(logger, "Starting data processing pipeline...")
     
     # Check if data file exists
     data_file = "sales_data.csv"
-    if not os.path.exists(data_file):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Creating sample data file...")
+    if not file_exists(data_file):
+        log_info(logger, "Creating sample data file...")
         create_sample_data(data_file)
     
     # Read data from CSV
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Reading data from {data_file}...")
-    data = []
-    try:
-        with open(data_file, 'r') as file:
-            reader = csv.DictReader(file)
-            for row in reader:
-                data.append(row)
-    except Exception as e:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error reading file: {e}")
+    log_info(logger, f"Reading data from {data_file}...")
+    data = read_csv_file(data_file)
+    
+    if data is None:
+        log_error(logger, "Error reading file")
         return
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Loaded {len(data)} records")
+    log_info(logger, f"Loaded {len(data)} records")
     
     # Clean the data
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Cleaning data...")
-    clean_data = []
-    for row in data:
-        if row.get('amount') and row.get('quantity'):
-            try:
-                amount = float(row['amount'])
-                quantity = int(row['quantity'])
-                # Round to 2 decimal places
-                amount = round(amount * 100) / 100
-                row['amount'] = amount
-                row['quantity'] = quantity
-                clean_data.append(row)
-            except ValueError:
-                print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Skipping invalid row")
+    log_info(logger, "Cleaning data...")
+    clean_data = clean_and_validate_data(data, logger)
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Cleaned data: {len(clean_data)} valid records")
+    log_info(logger, f"Cleaned data: {len(clean_data)} valid records")
     
     # Calculate basic statistics
     amounts = [float(row['amount']) for row in clean_data]
     if amounts:
-        total = sum(amounts)
-        average = total / len(amounts)
-        minimum = min(amounts)
-        maximum = max(amounts)
+        stats = calculate_statistics(amounts)
         
-        # Round results
-        total = round(total * 100) / 100
-        average = round(average * 100) / 100
-        minimum = round(minimum * 100) / 100
-        maximum = round(maximum * 100) / 100
+        log_info(logger, "Statistics calculated successfully")
+        log_info(logger, f"Total: {format_currency(stats['total'])}")
+        log_info(logger, f"Average: {format_currency(stats['average'])}")
+        log_info(logger, f"Min: {format_currency(stats['min'])}")
+        log_info(logger, f"Max: {format_currency(stats['max'])}")
+    
+    log_info(logger, "Pipeline completed successfully")
+
+
+def clean_and_validate_data(data: List[Dict[str, Any]], logger) -> List[Dict[str, Any]]:
+    """
+    Clean and validate data rows.
+    
+    Args:
+        data: List of data rows to clean
+        logger: Logger instance for output
         
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Statistics calculated successfully")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Total: ${total}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Average: ${average}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Min: ${minimum}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Max: ${maximum}")
+    Returns:
+        List of cleaned and validated data rows
+    """
+    clean_data = []
+    for row in data:
+        if validate_required_fields(row, ['amount', 'quantity']):
+            # Clean numeric fields
+            amount = clean_numeric_field(row['amount'], float)
+            quantity = clean_numeric_field(row['quantity'], int)
+            
+            if amount is not None and quantity is not None:
+                # Round amount to 2 decimal places
+                row['amount'] = round_to_decimal_places(amount)
+                row['quantity'] = quantity
+                clean_data.append(row)
+            else:
+                log_info(logger, "Skipping invalid row")
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Pipeline completed successfully")
+    return clean_data
 
-def create_sample_data(filename):
-    """Create sample CSV data for testing"""
+
+def create_sample_data(filename: str) -> None:
+    """
+    Create sample CSV data for testing.
+    
+    Args:
+        filename: Path to create the sample CSV file
+    """
     data = [
         {'date': '2025-01-01', 'product': 'Widget A', 'amount': '125.50', 'quantity': '10'},
         {'date': '2025-01-02', 'product': 'Widget B', 'amount': '87.25', 'quantity': '5'},
@@ -80,11 +99,8 @@
         {'date': '2025-01-05', 'product': 'Widget D', 'amount': '99.99', 'quantity': '8'},
     ]
     
-    with open(filename, 'w', newline='') as file:
-        fieldnames = ['date', 'product', 'amount', 'quantity']
-        writer = csv.DictWriter(file, fieldnames=fieldnames)
-        writer.writeheader()
-        writer.writerows(data)
+    create_sample_csv(filename, data)
+
 
 if __name__ == "__main__":
     main()
--- .backup/report_generator.py	2025-11-08 13:47:57.000000000 +0530
+++ report_generator.py	2025-11-08 13:48:54.000000000 +0530
@@ -3,83 +3,88 @@
 Creates formatted reports from processed data.
 """
 
-import csv
-import os
-from datetime import datetime
-
-def generate_report(data_file):
-    """Generate a formatted report from CSV data"""
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Generating report...")
+from typing import List, Dict, Any
+from utils.data_utils import file_exists, read_csv_file, clean_numeric_field
+from utils.math_utils import round_to_decimal_places, aggregate_by_key, calculate_statistics
+from utils.logging_utils import (
+    setup_logger, log_info, log_error, 
+    format_report_header, format_report_footer, format_currency
+)
+
+
+def generate_report(data_file: str) -> None:
+    """
+    Generate a formatted report from CSV data.
+    
+    Args:
+        data_file: Path to the CSV data file
+    """
+    # Set up logger
+    logger = setup_logger('report_generator')
+    
+    log_info(logger, "Generating report...")
     
     # Check if file exists
-    if not os.path.exists(data_file):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error: File {data_file} not found")
+    if not file_exists(data_file):
+        log_error(logger, f"Error: File {data_file} not found")
         return
     
     # Read CSV data
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Reading data from {data_file}...")
-    data = []
-    try:
-        with open(data_file, 'r') as file:
-            reader = csv.DictReader(file)
-            for row in reader:
-                data.append(row)
-    except Exception as e:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error reading file: {e}")
+    log_info(logger, f"Reading data from {data_file}...")
+    data = read_csv_file(data_file)
+    
+    if data is None:
+        log_error(logger, "Error reading file")
         return
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Loaded {len(data)} records")
+    log_info(logger, f"Loaded {len(data)} records")
     
     # Clean and process data
-    clean_data = []
-    for row in data:
-        if row.get('amount') and row.get('product'):
-            try:
-                amount = float(row['amount'])
-                # Round to 2 decimal places
-                amount = round(amount * 100) / 100
-                row['amount'] = amount
-                clean_data.append(row)
-            except ValueError:
-                continue
+    clean_data = clean_report_data(data)
     
-    # Calculate totals by product
-    product_totals = {}
-    for row in clean_data:
-        product = row['product']
-        amount = float(row['amount'])
-        if product in product_totals:
-            product_totals[product] += amount
-        else:
-            product_totals[product] = amount
-    
-    # Round product totals
-    for product in product_totals:
-        product_totals[product] = round(product_totals[product] * 100) / 100
+    # Calculate product totals
+    product_totals = aggregate_by_key(clean_data, 'product', 'amount')
     
     # Calculate overall statistics
     amounts = [float(row['amount']) for row in clean_data]
-    total = sum(amounts)
-    average = total / len(amounts) if amounts else 0
+    stats = calculate_statistics(amounts)
     
-    # Round results
-    total = round(total * 100) / 100
-    average = round(average * 100) / 100
-    
-    # Generate report
-    print(f"\n[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ========== SALES REPORT ==========")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Total Records: {len(clean_data)}")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Product Breakdown:")
+    # Generate report output
+    format_report_header("SALES REPORT", logger)
+    log_info(logger, f"Total Records: {len(clean_data)}")
+    log_info(logger, "")
+    log_info(logger, "Product Breakdown:")
     for product, amount in sorted(product_totals.items()):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   {product}: ${amount}")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Total Sales: ${total}")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Average Sale: ${average}")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ==================================\n")
+        log_info(logger, f"  {product}: {format_currency(amount)}")
+    log_info(logger, "")
+    log_info(logger, f"Total Sales: {format_currency(stats['total'])}")
+    log_info(logger, f"Average Sale: {format_currency(stats['average'])}")
+    format_report_footer(logger)
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Report generation completed")
+    log_info(logger, "Report generation completed")
+
+
+def clean_report_data(data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
+    """
+    Clean and validate data for report generation.
+    
+    Args:
+        data: List of raw data rows
+        
+    Returns:
+        List of cleaned data rows
+    """
+    clean_data = []
+    for row in data:
+        if row.get('amount') and row.get('product'):
+            amount = clean_numeric_field(row['amount'], float)
+            if amount is not None:
+                # Round to 2 decimal places
+                row['amount'] = round_to_decimal_places(amount)
+                clean_data.append(row)
+    
+    return clean_data
+
 
 if __name__ == "__main__":
     generate_report("sales_data.csv")
--- .backup/data_cleaner.py	2025-11-08 13:47:57.000000000 +0530
+++ data_cleaner.py	2025-11-08 13:49:28.000000000 +0530
@@ -3,124 +3,160 @@
 Handles data validation, cleaning, and normalization.
 """
 
-import csv
-import os
-from datetime import datetime
-
-def clean_csv_data(input_file, output_file):
-    """Clean CSV data and write to output file"""
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Starting data cleaning process...")
+from typing import List, Dict, Any, Optional
+from utils.data_utils import (
+    file_exists, read_csv_file, write_csv_file,
+    clean_numeric_field, clean_text_field,
+    validate_required_fields, validate_csv_structure
+)
+from utils.math_utils import round_to_decimal_places, validate_positive_number
+from utils.logging_utils import setup_logger, log_info, log_error
+
+
+def clean_csv_data(input_file: str, output_file: str) -> bool:
+    """
+    Clean CSV data and write to output file.
+    
+    Args:
+        input_file: Path to input CSV file
+        output_file: Path to output CSV file
+        
+    Returns:
+        True if successful, False otherwise
+    """
+    # Set up logger
+    logger = setup_logger('data_cleaner')
+    
+    log_info(logger, "Starting data cleaning process...")
     
     # Check if input file exists
-    if not os.path.exists(input_file):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error: Input file {input_file} not found")
+    if not file_exists(input_file):
+        log_error(logger, f"Error: Input file {input_file} not found")
         return False
     
     # Read input data
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Reading data from {input_file}...")
-    data = []
-    try:
-        with open(input_file, 'r') as file:
-            reader = csv.DictReader(file)
-            for row in reader:
-                data.append(row)
-    except Exception as e:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error reading file: {e}")
+    log_info(logger, f"Reading data from {input_file}...")
+    data = read_csv_file(input_file)
+    
+    if data is None:
+        log_error(logger, "Error reading file")
         return False
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Loaded {len(data)} records")
+    log_info(logger, f"Loaded {len(data)} records")
     
     # Clean and validate data
+    clean_data, invalid_count = clean_and_validate_rows(data, logger)
+    
+    log_info(logger, f"Cleaned {len(clean_data)} records, skipped {invalid_count} invalid records")
+    
+    # Write cleaned data to output file
+    if clean_data:
+        log_info(logger, f"Writing cleaned data to {output_file}...")
+        fieldnames = ['date', 'product', 'amount', 'quantity']
+        success = write_csv_file(output_file, clean_data, fieldnames)
+        
+        if success:
+            log_info(logger, "Data cleaning completed successfully")
+            return True
+        else:
+            log_error(logger, "Error writing output file")
+            return False
+    else:
+        log_info(logger, "No valid data to write")
+        return False
+
+
+def clean_and_validate_rows(data: List[Dict[str, Any]], logger) -> tuple[List[Dict[str, Any]], int]:
+    """
+    Clean and validate data rows.
+    
+    Args:
+        data: List of raw data rows
+        logger: Logger instance
+        
+    Returns:
+        Tuple of (cleaned data list, invalid count)
+    """
     clean_data = []
     invalid_count = 0
+    required_fields = ['amount', 'quantity', 'product']
     
     for row in data:
         # Validate required fields
-        if not row.get('amount') or not row.get('quantity') or not row.get('product'):
+        if not validate_required_fields(row, required_fields):
             invalid_count += 1
-            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Skipping row with missing fields")
+            log_info(logger, "Skipping row with missing fields")
             continue
         
-        try:
-            # Clean and convert numeric fields
-            amount = float(row['amount'])
-            quantity = int(row['quantity'])
-            
-            # Round amount to 2 decimal places
-            amount = round(amount * 100) / 100
-            
-            # Validate ranges
-            if amount < 0 or quantity < 0:
-                invalid_count += 1
-                print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Skipping row with negative values")
-                continue
-            
-            # Clean product name (remove extra whitespace)
-            product = ' '.join(row['product'].split())
-            
-            # Create cleaned row
-            clean_row = {
-                'date': row.get('date', ''),
-                'product': product,
-                'amount': amount,
-                'quantity': quantity
-            }
-            clean_data.append(clean_row)
-            
-        except (ValueError, TypeError) as e:
+        # Clean and convert numeric fields
+        amount = clean_numeric_field(row['amount'], float)
+        quantity = clean_numeric_field(row['quantity'], int)
+        
+        if amount is None or quantity is None:
             invalid_count += 1
-            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Skipping row with invalid data: {e}")
+            log_info(logger, "Skipping row with invalid data")
             continue
+        
+        # Round amount to 2 decimal places
+        amount = round_to_decimal_places(amount)
+        
+        # Validate ranges
+        if not validate_positive_number(amount) or not validate_positive_number(quantity):
+            invalid_count += 1
+            log_info(logger, "Skipping row with negative values")
+            continue
+        
+        # Clean product name
+        product = clean_text_field(row['product'])
+        
+        # Create cleaned row
+        clean_row = {
+            'date': row.get('date', ''),
+            'product': product,
+            'amount': amount,
+            'quantity': quantity
+        }
+        clean_data.append(clean_row)
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Cleaned {len(clean_data)} records, skipped {invalid_count} invalid records")
+    return clean_data, invalid_count
+
+
+def validate_data_file(filename: str) -> bool:
+    """
+    Validate a CSV data file.
     
-    # Write cleaned data to output file
-    if clean_data:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Writing cleaned data to {output_file}...")
-        try:
-            with open(output_file, 'w', newline='') as file:
-                fieldnames = ['date', 'product', 'amount', 'quantity']
-                writer = csv.DictWriter(file, fieldnames=fieldnames)
-                writer.writeheader()
-                writer.writerows(clean_data)
-            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Data cleaning completed successfully")
-            return True
-        except Exception as e:
-            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error writing output file: {e}")
-            return False
-    else:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] No valid data to write")
+    Args:
+        filename: Path to CSV file to validate
+        
+    Returns:
+        True if valid, False otherwise
+    """
+    # Set up logger
+    logger = setup_logger('data_validator')
+    
+    log_info(logger, f"Validating {filename}...")
+    
+    if not file_exists(filename):
+        log_info(logger, "File does not exist")
         return False
-
-def validate_data_file(filename):
-    """Validate a CSV data file"""
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Validating {filename}...")
     
-    if not os.path.exists(filename):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] File does not exist")
+    # Read and check file structure
+    data = read_csv_file(filename)
+    if data is None:
+        log_error(logger, "Validation error: Cannot read file")
         return False
     
-    try:
-        with open(filename, 'r') as file:
-            reader = csv.DictReader(file)
-            rows = list(reader)
-            
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] File contains {len(rows)} rows")
-        
-        # Check for required fields
-        required_fields = ['date', 'product', 'amount', 'quantity']
-        if rows:
-            missing = [field for field in required_fields if field not in rows[0]]
-            if missing:
-                print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Missing required fields: {missing}")
-                return False
-        
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Validation passed")
-        return True
-        
-    except Exception as e:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Validation error: {e}")
+    log_info(logger, f"File contains {len(data)} rows")
+    
+    # Check for required fields
+    required_fields = ['date', 'product', 'amount', 'quantity']
+    if not validate_csv_structure(filename, required_fields):
+        log_info(logger, f"Missing required fields")
         return False
+    
+    log_info(logger, "Validation passed")
+    return True
+
 
 if __name__ == "__main__":
     clean_csv_data("sales_data.csv", "sales_data_clean.csv")
--- .backup/analyzer.py	2025-11-08 13:47:57.000000000 +0530
+++ analyzer.py	2025-11-08 13:50:11.000000000 +0530
@@ -3,153 +3,189 @@
 Performs statistical analysis and calculations on data.
 """
 
-import csv
-import os
-from datetime import datetime
-
-def analyze_sales_data(data_file):
-    """Analyze sales data and calculate statistics"""
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Starting data analysis...")
+from typing import Dict, Any, Optional, List
+from utils.data_utils import file_exists, read_csv_file, clean_numeric_field
+from utils.math_utils import round_to_decimal_places, calculate_statistics
+from utils.logging_utils import (
+    setup_logger, log_info, log_error,
+    format_report_header, format_report_footer, format_currency
+)
+
+
+def analyze_sales_data(data_file: str) -> Optional[Dict[str, Any]]:
+    """
+    Analyze sales data and calculate statistics.
+    
+    Args:
+        data_file: Path to the CSV data file
+        
+    Returns:
+        Dictionary containing analysis results, or None if error occurs
+    """
+    # Set up logger
+    logger = setup_logger('analyzer')
+    
+    log_info(logger, "Starting data analysis...")
     
     # Check if file exists
-    if not os.path.exists(data_file):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error: File {data_file} not found")
+    if not file_exists(data_file):
+        log_error(logger, f"Error: File {data_file} not found")
         return None
     
     # Read CSV data
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Loading data from {data_file}...")
-    data = []
-    try:
-        with open(data_file, 'r') as file:
-            reader = csv.DictReader(file)
-            for row in reader:
-                data.append(row)
-    except Exception as e:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Error reading file: {e}")
+    log_info(logger, f"Loading data from {data_file}...")
+    data = read_csv_file(data_file)
+    
+    if data is None:
+        log_error(logger, "Error reading file")
         return None
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Loaded {len(data)} records")
+    log_info(logger, f"Loaded {len(data)} records")
     
-    # Clean and convert data
-    amounts = []
-    quantities = []
-    
-    for row in data:
-        try:
-            if row.get('amount'):
-                amount = float(row['amount'])
-                # Round to 2 decimal places
-                amount = round(amount * 100) / 100
-                amounts.append(amount)
-            
-            if row.get('quantity'):
-                quantity = int(row['quantity'])
-                quantities.append(quantity)
-        except (ValueError, TypeError):
-            print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Skipping invalid row")
-            continue
+    # Extract and clean numeric data
+    amounts, quantities = extract_numeric_data(data, logger)
     
     # Calculate amount statistics
-    amount_stats = {}
-    if amounts:
-        total_amount = sum(amounts)
-        avg_amount = total_amount / len(amounts)
-        min_amount = min(amounts)
-        max_amount = max(amounts)
-        
-        # Round results
-        amount_stats = {
-            'total': round(total_amount * 100) / 100,
-            'average': round(avg_amount * 100) / 100,
-            'min': round(min_amount * 100) / 100,
-            'max': round(max_amount * 100) / 100,
-            'count': len(amounts)
-        }
+    amount_stats = calculate_statistics(amounts) if amounts else {}
     
     # Calculate quantity statistics
-    quantity_stats = {}
-    if quantities:
-        total_qty = sum(quantities)
-        avg_qty = total_qty / len(quantities)
-        min_qty = min(quantities)
-        max_qty = max(quantities)
-        
-        # Round results
-        quantity_stats = {
-            'total': total_qty,
-            'average': round(avg_qty * 100) / 100,
-            'min': min_qty,
-            'max': max_qty,
-            'count': len(quantities)
-        }
+    quantity_stats = calculate_statistics(quantities) if quantities else {}
     
     # Calculate product-wise statistics
+    product_stats = calculate_product_statistics(data)
+    
+    # Print analysis results
+    print_analysis_results(logger, amount_stats, quantity_stats, product_stats)
+    
+    log_info(logger, "Analysis completed successfully")
+    
+    return {
+        'amount_stats': amount_stats,
+        'quantity_stats': quantity_stats,
+        'product_stats': product_stats
+    }
+
+
+def extract_numeric_data(data: List[Dict[str, Any]], logger) -> tuple[List[float], List[int]]:
+    """
+    Extract and clean numeric data from rows.
+    
+    Args:
+        data: List of data rows
+        logger: Logger instance
+        
+    Returns:
+        Tuple of (amounts list, quantities list)
+    """
+    amounts = []
+    quantities = []
+    
+    for row in data:
+        # Clean amount field
+        amount = clean_numeric_field(row.get('amount'), float)
+        if amount is not None:
+            amounts.append(round_to_decimal_places(amount))
+        
+        # Clean quantity field
+        quantity = clean_numeric_field(row.get('quantity'), int)
+        if quantity is not None:
+            quantities.append(quantity)
+        
+        # Log if both fields are invalid
+        if amount is None and quantity is None:
+            log_info(logger, "Skipping invalid row")
+    
+    return amounts, quantities
+
+
+def calculate_product_statistics(data: List[Dict[str, Any]]) -> Dict[str, Dict[str, float]]:
+    """
+    Calculate statistics grouped by product.
+    
+    Args:
+        data: List of data rows
+        
+    Returns:
+        Dictionary mapping products to their statistics
+    """
     product_stats = {}
+    
     for row in data:
-        try:
-            product = row.get('product')
-            amount = float(row.get('amount', 0))
-            quantity = int(row.get('quantity', 0))
-            
+        product = row.get('product')
+        amount = clean_numeric_field(row.get('amount', 0), float)
+        quantity = clean_numeric_field(row.get('quantity', 0), int)
+        
+        if product and amount is not None and quantity is not None:
             # Round amount
-            amount = round(amount * 100) / 100
+            amount = round_to_decimal_places(amount)
+            
+            # Initialize product entry if needed
+            if product not in product_stats:
+                product_stats[product] = {
+                    'total_amount': 0.0,
+                    'total_quantity': 0,
+                    'count': 0
+                }
             
-            if product:
-                if product not in product_stats:
-                    product_stats[product] = {
-                        'total_amount': 0,
-                        'total_quantity': 0,
-                        'count': 0
-                    }
-                
-                product_stats[product]['total_amount'] += amount
-                product_stats[product]['total_quantity'] += quantity
-                product_stats[product]['count'] += 1
-        except (ValueError, TypeError):
-            continue
+            # Aggregate values
+            product_stats[product]['total_amount'] += amount
+            product_stats[product]['total_quantity'] += quantity
+            product_stats[product]['count'] += 1
     
-    # Round product totals
+    # Calculate averages and round totals
     for product in product_stats:
-        product_stats[product]['total_amount'] = round(product_stats[product]['total_amount'] * 100) / 100
-        avg = product_stats[product]['total_amount'] / product_stats[product]['count']
-        product_stats[product]['average_amount'] = round(avg * 100) / 100
+        total = product_stats[product]['total_amount']
+        count = product_stats[product]['count']
+        
+        product_stats[product]['total_amount'] = round_to_decimal_places(total)
+        product_stats[product]['average_amount'] = round_to_decimal_places(total / count)
     
-    # Print analysis results
-    print(f"\n[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ========== ANALYSIS RESULTS ==========")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Amount Statistics:")
+    return product_stats
+
+
+def print_analysis_results(
+    logger,
+    amount_stats: Dict[str, Any],
+    quantity_stats: Dict[str, Any],
+    product_stats: Dict[str, Dict[str, float]]
+) -> None:
+    """
+    Print formatted analysis results.
+    
+    Args:
+        logger: Logger instance
+        amount_stats: Amount statistics dictionary
+        quantity_stats: Quantity statistics dictionary
+        product_stats: Product-wise statistics dictionary
+    """
+    format_report_header("ANALYSIS RESULTS", logger)
+    
+    log_info(logger, "Amount Statistics:")
     if amount_stats:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Total: ${amount_stats['total']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Average: ${amount_stats['average']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Min: ${amount_stats['min']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Max: ${amount_stats['max']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Count: {amount_stats['count']}")
+        log_info(logger, f"  Total: {format_currency(amount_stats['total'])}")
+        log_info(logger, f"  Average: {format_currency(amount_stats['average'])}")
+        log_info(logger, f"  Min: {format_currency(amount_stats['min'])}")
+        log_info(logger, f"  Max: {format_currency(amount_stats['max'])}")
+        log_info(logger, f"  Count: {amount_stats['count']}")
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Quantity Statistics:")
+    log_info(logger, "")
+    log_info(logger, "Quantity Statistics:")
     if quantity_stats:
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Total: {quantity_stats['total']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Average: {quantity_stats['average']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Min: {quantity_stats['min']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   Max: {quantity_stats['max']}")
+        log_info(logger, f"  Total: {quantity_stats['total']}")
+        log_info(logger, f"  Average: {quantity_stats['average']}")
+        log_info(logger, f"  Min: {quantity_stats['min']}")
+        log_info(logger, f"  Max: {quantity_stats['max']}")
     
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ")
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Product Statistics:")
+    log_info(logger, "")
+    log_info(logger, "Product Statistics:")
     for product, stats in sorted(product_stats.items()):
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]   {product}:")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]     Total Sales: ${stats['total_amount']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]     Average Sale: ${stats['average_amount']}")
-        print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}]     Total Quantity: {stats['total_quantity']}")
-    
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] ======================================\n")
-    
-    print(f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] Analysis completed successfully")
+        log_info(logger, f"  {product}:")
+        log_info(logger, f"    Total Sales: {format_currency(stats['total_amount'])}")
+        log_info(logger, f"    Average Sale: {format_currency(stats['average_amount'])}")
+        log_info(logger, f"    Total Quantity: {stats['total_quantity']}")
     
-    return {
-        'amount_stats': amount_stats,
-        'quantity_stats': quantity_stats,
-        'product_stats': product_stats
-    }
+    format_report_footer(logger)
+
 
 if __name__ == "__main__":
     analyze_sales_data("sales_data.csv")
